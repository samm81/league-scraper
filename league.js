// Generated by CoffeeScript 1.7.1
var LolApi, divisionToPoints, fs, getCSRatioAndNumGames, getRank, getRanked, importOldFile, importedIDs, maxID, outFile, prevIDFile, prevIDOut, processNextID, processNextImportedID, readPrevIDs, statsOut, tierToPoints, writeID, writeStat,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

prevIDFile = process.argv[2];

outFile = process.argv[3];

if (prevIDFile === void 0 || outFile === void 0) {
  console.log("Usage: node league.js [id file] [data file]\n" + "output file headers:\n" + "summoner id, rank, points, cs per game, kills per game, assists per game, turrets per game, win ratio, number of games\n");
  throw "Invalid parameters error";
}

fs = require('fs');

statsOut = fs.createWriteStream(outFile, {
  flags: 'a',
  encoding: 'ascii'
});

prevIDOut = fs.createWriteStream(prevIDFile, {
  flags: 'a',
  encoding: 'ascii'
});

LolApi = require('leagueapi');

LolApi.init('d3551528-1503-4e23-91ab-b070c96df4a5');

maxID = 10000000;

tierToPoints = {
  "BRONZE": 0,
  "SILVER": 500,
  "GOLD": 1000,
  "PLATINUM": 1500,
  "DIAMOND": 2000,
  "CHALLENGER": 2500
};

divisionToPoints = {
  "V": 0,
  "IV": 100,
  "III": 200,
  "II": 300,
  "I": 400
};

writeStat = function(stat) {
  return statsOut.write(stat, (function(err) {
    if (err) {
      throw err;
    }
  }));
};

getRank = function(summonerID) {
  return LolApi.getLeagueEntryData(summonerID, (function(error, data) {
    var division, leaguePoints, points, rank, ranked, tier;
    if (!error) {
      ranked = data[summonerID][0];
      if (ranked !== null && ranked.queue === "RANKED_SOLO_5x5") {
        console.log("...had data");
        tier = ranked.tier;
        division = ranked.entries[0].division;
        leaguePoints = ranked.entries[0].leaguePoints;
        rank = tier + " " + division;
        if (tier === "CHALLENGER") {
          division = "V";
        }
        points = tierToPoints[tier] + divisionToPoints[division] + leaguePoints;
        writeStat("" + summonerID + ", " + rank + ", " + points + ", ");
        return getCSRatioAndNumGames(summonerID);
      }
    }
  }));
};

getRanked = function(data) {
  var datum, ranked, _i, _len;
  ranked = null;
  for (_i = 0, _len = data.length; _i < _len; _i++) {
    datum = data[_i];
    if (datum.playerStatSummaryType === "RankedSolo5x5") {
      ranked = datum;
    }
  }
  return ranked;
};

getCSRatioAndNumGames = function(summonerID) {
  return LolApi.Stats.getPlayerSummary(summonerID, 4, (function(error, data) {
    var assists, assistsPerGame, cs, csPerGame, games, kills, killsPerGame, losses, ranked, turrets, turretsPerGame, winRatio, wins;
    ranked = getRanked(data);
    if (ranked !== null) {
      wins = ranked.wins;
      losses = ranked.losses;
      games = wins + losses;
      winRatio = wins / games;
      winRatio = winRatio.toFixed(3);
      cs = ranked.aggregatedStats.totalMinionKills;
      csPerGame = cs / games;
      csPerGame = csPerGame.toFixed(3);
      kills = ranked.aggregatedStats.totalChampionKills;
      killsPerGame = kills / games;
      killsPerGame = killsPerGame.toFixed(3);
      assists = ranked.aggregatedStats.totalAssists;
      assistsPerGame = assists / games;
      assistsPerGame = assistsPerGame.toFixed(3);
      turrets = ranked.aggregatedStats.totalTurretsKilled;
      turretsPerGame = turrets / games;
      turretsPerGame = turretsPerGame.toFixed(3);
      return writeStat(csPerGame + ", " + killsPerGame + ", " + assistsPerGame + ", " + turretsPerGame + ", " + winRatio + ", " + games + "\n");
    } else {
      return writeStat("NoRanked\n");
    }
  }));
};

writeID = function(id) {
  return prevIDOut.write("\n" + id, (function(err) {
    if (err) {
      throw err;
    }
  }));
};

processNextID = function(prevIDs) {
  var id;
  id = Math.floor(Math.random() * maxID + 1);
  console.log(id);
  if (__indexOf.call(prevIDs, id) < 0) {
    console.log("...was not previously processed");
    getRank(id);
    prevIDs.push(id);
    writeID(id);
  } else {
    console.log("...was previously processed");
  }
  return setTimeout((function() {
    return processNextID(prevIDs);
  }), 1400);
};

readPrevIDs = function() {
  console.log("loading previous ids...");
  return fs.readFile(prevIDFile, 'ascii', (function(err, data) {
    var prevIDString, prevIDStrings, prevIDs, _i, _len;
    if (err) {
      throw err;
    }
    prevIDStrings = data.split("\n");
    prevIDs = [];
    for (_i = 0, _len = prevIDStrings.length; _i < _len; _i++) {
      prevIDString = prevIDStrings[_i];
      prevIDs.push(parseInt(prevIDString));
    }
    console.log("...loaded " + prevIDs.length + " ids");
    return processNextID(prevIDs);
  }));
};

importedIDs = [];

importOldFile = function(importFile) {
  console.log("importing previous file...");
  return fs.readFile(importFile, 'ascii', (function(err, data) {
    var i, id, oldDataString, oldDataStrings, _i, _len, _results;
    if (err) {
      throw err;
    }
    oldDataStrings = data.split("\n");
    i = 0;
    _results = [];
    for (_i = 0, _len = oldDataStrings.length; _i < _len; _i++) {
      oldDataString = oldDataStrings[_i];
      id = (oldDataString.split(","))[0];
      _results.push(importedIDs.push(id));
    }
    return _results;
  }));
};

processNextImportedID = function(index) {
  var id;
  id = importedIDs[index];
  console.log("importing " + id);
  getRank(id);
  writeID(id);
  return setTimeout((function() {
    return processNextImportedID(index + 1);
  }), 3000);
};

if (process.argv[4] === "-import") {
  importOldFile(process.argv[5]);
  setTimeout((function() {
    return processNextImportedID(0);
  }), 5000);
} else {
  readPrevIDs();
}
